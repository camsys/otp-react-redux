{"version":3,"sources":["../src/query.js"],"names":["moment","getGeocoder","qs","getTransitModes","hasCar","hasTransit","isAccessMode","toSentenceCase","coordsToString","matchLatLon","stringToCoords","queryParams","getCurrentTime","getCurrentDate","OTP_API_DATE_FORMAT","OTP_API_TIME_FORMAT","defaultParams","TIME_FORMATS","getQueryParamProperty","paramInfo","property","query","ensureSingleAccessMode","queryModes","accessCount","filter","m","length","firstAccess","find","push","getUrlParams","parse","window","location","href","split","getOtpUrlParams","Object","keys","key","startsWith","findLocationType","locations","types","match","l","indexOf","type","summarizeQuery","from","name","to","mode","getTripOptionsFromQuery","keepPlace","options","time","departArrive","date","getDefaultQueryParamValue","param","getDefaultQuery","config","defaultQuery","routingType","qp","forEach","routingTypes","defaultQueryParams","isParamApplicable","applicable","includes","reduceOtpFlexModes","modes","reduce","prev","cur","newModes","expandOtpFlexMode","map","join","isNotDefaultQuery","activeModes","sort","defaultModes","concat","modesEqual","every","value","index","i","getFirstGeocodeResult","text","geocoderConfig","geocoder","search","then","result","firstResult","features","getLocationFromGeocodedFeature","parseLocationString","parts","coordinates","lat","lon","queryParamToLocation","planParamsToQuery","params","fromPlace","toPlace","arriveBy","parsedTime","isValid","format","intermediatePlaces","maybeNumber","Number","isNaN","planParamsToQueryAsync","getRoutingParams","currentQuery","ignoreRealtimeUpdates","isItinerary","rewriteFunction","itineraryRewrite","profileRewrite","assign","dateValid","timeValid","minTransitDistance","searchTimeout","onlyTransitTrips","startTimeValid","startTime","endTimeValid","endTime","reducedMode"],"mappings":"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","sourcesContent":["import moment from \"moment\";\nimport getGeocoder from \"@opentripplanner/geocoder/lib\";\nimport qs from \"qs\";\n\nimport {\n  getTransitModes,\n  hasCar,\n  hasTransit,\n  isAccessMode,\n  toSentenceCase\n} from \"./itinerary\";\nimport { coordsToString, matchLatLon, stringToCoords } from \"./map\";\nimport queryParams from \"./query-params\";\nimport {\n  getCurrentTime,\n  getCurrentDate,\n  OTP_API_DATE_FORMAT,\n  OTP_API_TIME_FORMAT\n} from \"./time\";\n\n/* The list of default parameters considered in the settings panel */\n\nexport const defaultParams = [\n  \"wheelchair\",\n  \"maxWalkDistance\",\n  \"maxWalkTime\",\n  \"walkSpeed\",\n  \"maxBikeDistance\",\n  \"maxBikeTime\",\n  \"bikeSpeed\",\n  \"optimize\",\n  \"optimizeBike\",\n  \"maxEScooterDistance\",\n  \"watts\"\n];\n\n/**\n * List of time formats to parse when reading query params.\n */\nconst TIME_FORMATS = [\n  \"HH:mm:ss\",\n  \"h:mm:ss a\",\n  \"h:mm:ssa\",\n  \"h:mm a\",\n  \"h:mma\",\n  \"h:mm\",\n  \"HHmm\",\n  \"hmm\",\n  \"ha\",\n  OTP_API_TIME_FORMAT // 'HH:mm'\n];\n\n/* A function to retrieve a property value from an entry in the query-params\n * table, checking for either a static value or a function */\n\nexport function getQueryParamProperty(paramInfo, property, query) {\n  return typeof paramInfo[property] === \"function\"\n    ? paramInfo[property](query)\n    : paramInfo[property];\n}\n\nexport function ensureSingleAccessMode(queryModes) {\n  // Count the number of access modes\n  const accessCount = queryModes.filter(m => isAccessMode(m)).length;\n\n  // If multiple access modes are specified, keep only the first one\n  if (accessCount > 1) {\n    const firstAccess = queryModes.find(m => isAccessMode(m));\n    queryModes = queryModes.filter(m => !isAccessMode(m) || m === firstAccess);\n\n    // If no access modes are specified, add 'WALK' as the default\n  } else if (accessCount === 0) {\n    queryModes.push(\"WALK\");\n  }\n\n  return queryModes;\n}\n\nexport function getUrlParams() {\n  return qs.parse(window.location.href.split(\"?\")[1]);\n}\n\nexport function getOtpUrlParams() {\n  return Object.keys(getUrlParams()).filter(key => !key.startsWith(\"ui_\"));\n}\n\nfunction findLocationType(\n  location,\n  locations = [],\n  types = [\"home\", \"work\", \"suggested\"]\n) {\n  const match = locations.find(l => matchLatLon(l, location));\n  return match && types.indexOf(match.type) !== -1 ? match.type : null;\n}\n\nexport function summarizeQuery(query, locations = []) {\n  const from =\n    findLocationType(query.from, locations) || query.from.name.split(\",\")[0];\n  const to =\n    findLocationType(query.to, locations) || query.to.name.split(\",\")[0];\n  const mode = hasTransit(query.mode) ? \"Transit\" : toSentenceCase(query.mode);\n  return `${mode} from ${from} to ${to}`;\n}\n\nexport function getTripOptionsFromQuery(query, keepPlace = false) {\n  const options = { ...query };\n  // Delete time/date options and from/to\n  delete options.time;\n  delete options.departArrive;\n  delete options.date;\n  if (!keepPlace) {\n    delete options.from;\n    delete options.to;\n  }\n  return options;\n}\n\n/**\n * Gets the query param's default value that is either a constant or by\n * executing the default value function.\n */\nfunction getDefaultQueryParamValue(param) {\n  return typeof param.default === \"function\" ? param.default() : param.default;\n}\n\n/**\n * Get the default query to OTP based on the given config.\n */\nexport function getDefaultQuery(config = null) {\n  const defaultQuery = { routingType: \"ITINERARY\" };\n  queryParams\n    .filter(qp => \"default\" in qp)\n    .forEach(qp => {\n      defaultQuery[qp.name] = getDefaultQueryParamValue(qp);\n    });\n  if (config) {\n    if (config.routingTypes && config.routingTypes.length > 0) {\n      defaultQuery.routingType = config.routingTypes[0].key;\n    }\n    if (config.defaultQueryParams) {\n      Object.keys(config.defaultQueryParams).forEach(key => {\n        defaultQuery[key] = config.defaultQueryParams[key];\n      });\n    }\n  }\n  return defaultQuery;\n}\n\n/**\n * Determine if the specified query param applies to the given query (based on\n * routing type and the param's own applicable function).\n * @param  paramInfo an entry from query-params.js\n * @param  query     the query against which to check if the param applies\n * @param  config    OTP config\n * @return {Boolean}\n */\nfunction isParamApplicable(paramInfo, query, config) {\n  const { applicable, routingTypes } = paramInfo;\n  if (!routingTypes.includes(query.routingType)) return false;\n  if (typeof applicable === \"function\" && !applicable(query, config)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Helper method which replaces OTP flex modes with single FLEX mode that's\n * more useful and easier to work with.\n */\nexport function reduceOtpFlexModes(modes) {\n  return modes.reduce((prev, cur) => {\n    const newModes = prev;\n    // Add the current mode if it is not a flex mode\n    if (!cur.includes(\"FLEX\")) {\n      newModes.push(cur);\n      // If it is a flex mode, do not add it but rather add the custom flex mode\n      // if not already present\n    } else if (!newModes.includes(\"FLEX\")) {\n      newModes.push(\"FLEX\");\n    }\n    return newModes;\n  }, []);\n}\n\n/**\n * Helper method to process a mode string, replacing all instances of FLEX\n * with the full set of FLEX modes used by otp-2\n * @param {*} mode a mode String, not an array\n * @returns a mode String, not an array (with flex modes expanded)\n */\nexport function expandOtpFlexMode(mode) {\n  const modes = reduceOtpFlexModes(mode.split(\",\"));\n  return modes\n    .map(m => {\n      // If both the expanded and shrunk modes are included, remove the exapnded one\n      if (m === \"FLEX_EGRESS\" || m === \"FLEX_ACCESS\" || m === \"FLEX_DIRECT\") {\n        if (mode.includes(\"FLEX\")) return \"\";\n      }\n      if (m === \"FLEX\") {\n        return \"FLEX_EGRESS,FLEX_ACCESS,FLEX_DIRECT\";\n      }\n      return m;\n    })\n    .join(\",\");\n}\n\n/**\n * Determines whether the specified query differs from the default query, i.e.,\n * whether the user has modified any trip options (including mode) from their\n * default values.\n */\nexport function isNotDefaultQuery(query, config) {\n  const activeModes = reduceOtpFlexModes(query.mode.split(\",\").sort());\n  if (\n    activeModes.length !== 2 ||\n    activeModes[0] !== \"TRANSIT\" ||\n    activeModes[1] !== \"WALK\"\n  ) {\n    // Default mode is TRANSIT,WALK. If general TRANSIT is not used, check\n    // against available transit modes in config.\n    const defaultModes = getTransitModes(config)\n      .concat([\"WALK\"])\n      .sort();\n    const modesEqual =\n      activeModes.length === defaultModes.length &&\n      activeModes.every((value, index) => {\n        return value === defaultModes[index];\n      });\n    if (!modesEqual) return true;\n  }\n  // If modes are equal, check the remaining params.\n  const defaultQuery = getDefaultQuery(config);\n  for (let i = 0; i < defaultParams.length; i++) {\n    const param = defaultParams[i];\n    const paramInfo = queryParams.find(qp => qp.name === param);\n    // If the parameter applies to the query and does not match the default\n    // value, the query is not default.\n    if (\n      isParamApplicable(paramInfo, query, config) &&\n      query[param] !== defaultQuery[param]\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Geocode utility for returning the first result for the provided place name text.\n * @param  {string} text - text to search\n * @param  {Object} geocoderConfig\n * @return {Location}\n */\nasync function getFirstGeocodeResult(text, geocoderConfig) {\n  const geocoder = getGeocoder(geocoderConfig);\n  // Attempt to geocode search text and return first result if found.\n  // TODO: Import geocoder from @opentripplanner\n  return geocoder.search({ text }).then(result => {\n    const firstResult = result.features && result.features[0];\n    if (firstResult) {\n      return geocoder.getLocationFromGeocodedFeature(firstResult);\n    }\n    return null;\n  });\n}\n\n/**\n * OTP allows passing a location in the form '123 Main St::lat,lon', so we check\n * for the double colon and parse the coordinates accordingly.\n * @param  {string} value - query param for place described above\n * @return {Location} - location or null if the value is falsey or the parsed\n *                      coordinates do not result in both a lat and lon\n */\nexport function parseLocationString(value) {\n  if (!value) return null;\n  const parts = value.split(\"::\");\n  const coordinates = parts[1]\n    ? stringToCoords(parts[1])\n    : stringToCoords(parts[0]);\n  const name = parts[1] ? parts[0] : coordsToString(coordinates);\n  return coordinates.length === 2\n    ? {\n        name: name || null,\n        lat: coordinates[0] || null,\n        lon: coordinates[1] || null\n      }\n    : null;\n}\n\n/**\n * Convert a string query param for a from or to place into a location. If\n * coordinates not provided and geocoder config is present, use the first\n * geocoded result.\n * @param  {string} value\n * @param  {Object} [geocoderConfig=null]\n * @return {Location}\n */\nasync function queryParamToLocation(value, geocoderConfig) {\n  let location = parseLocationString(value);\n  if (!location && value && geocoderConfig) {\n    // If a valid location was not found, but the place name text exists,\n    // attempt to geocode the name.\n    location = await getFirstGeocodeResult(value, geocoderConfig);\n  }\n  return location;\n}\n\n/**\n * Create a otp query based on a the url params.\n *\n * @param  {Object} params An object representing the parsed querystring of url\n *    params.\n */\nexport function planParamsToQuery(params) {\n  const query = {};\n  Object.keys(params).forEach(key => {\n    switch (key) {\n      case \"fromPlace\":\n        query.from = parseLocationString(params.fromPlace);\n        break;\n      case \"toPlace\":\n        query.to = parseLocationString(params.toPlace);\n        break;\n      case \"arriveBy\":\n        query.departArrive =\n          params.arriveBy === \"true\"\n            ? \"ARRIVE\"\n            : params.arriveBy === \"false\"\n            ? \"DEPART\"\n            : \"NOW\";\n        break;\n      case \"date\":\n        query.date = params.date || getCurrentDate();\n        break;\n      case \"time\":\n        {\n          const parsedTime = moment(params.time, TIME_FORMATS);\n          query.time = parsedTime.isValid()\n            ? parsedTime.format(OTP_API_TIME_FORMAT)\n            : getCurrentTime();\n        }\n        break;\n      case \"intermediatePlaces\":\n        // If query has intermediate places, ensure that they are parsed\n        // as locations.\n        query.intermediatePlaces = params.intermediatePlaces\n          ? params.intermediatePlaces.map(parseLocationString)\n          : [];\n        break;\n      default: {\n        const maybeNumber = Number(params[key]);\n        // If the param value is an empty string literal and is not a number,\n        // use string value. Else, use parsed number value.\n        // See https://github.com/opentripplanner/otp-ui/issues/50\n        query[key] =\n          params[key] === \"\" || Number.isNaN(maybeNumber)\n            ? params[key]\n            : maybeNumber;\n        break;\n      }\n    }\n  });\n  return query;\n}\n\n/**\n * Async method to create a otp query based on a the url params. This provides\n * the same functionality as planParamsToQuery, except that it will also attempt\n * to geocode the input from and to strings if no lat/lng values were provided.\n *\n * @param  {Object} params An object representing the parsed querystring of url\n *    params.\n * @param config the config in the otp-rr store.\n */\nexport async function planParamsToQueryAsync(params, config = {}) {\n  // Construct query from plan params.\n  const query = planParamsToQuery(params);\n  // Attempt to geocode from and to params if the string parsing does not return\n  // valid locations.\n  if (!query.from) {\n    query.from = await queryParamToLocation(params.fromPlace, config.geocoder);\n  }\n  if (!query.to) {\n    query.to = await queryParamToLocation(params.toPlace, config.geocoder);\n  }\n  return query;\n}\n\n/**\n * Create an object that can be used as a querystring in making an OTP\n * PlannerResource request.\n *\n * See http://otp-docs.ibi-transit.com/api/resource_PlannerResource.html\n *\n * @param  {Object} config  The OTP application config. See types#configType\n * @param  {Object} currentQuery  The current query parameters as saved in the\n *   application state. This method does some extra logic on top of this data\n *   in order to create a request suitable for OTP. See __tests__/query.js#L14 for more.\n * @param  {boolean} ignoreRealtimeUpdates  If true, will create a request that\n *   does not use realtime data.\n */\nexport function getRoutingParams(config, currentQuery, ignoreRealtimeUpdates) {\n  const routingType = currentQuery.routingType;\n  const isItinerary = routingType === \"ITINERARY\";\n  let params = {};\n\n  // Start with the universe of OTP parameters defined in query-params.js:\n  queryParams\n    .filter(qp => {\n      // A given parameter is included in the request if all of the following:\n      // 1. Must apply to the active routing type (ITINERARY or PROFILE)\n      // 2. Must be included in the current user-defined query\n      // 3. Must pass the parameter's applicability test, if one is specified\n      return (\n        qp.routingTypes.indexOf(routingType) !== -1 &&\n        qp.name in currentQuery &&\n        (typeof qp.applicable !== \"function\" ||\n          qp.applicable(currentQuery, config))\n      );\n    })\n    .forEach(qp => {\n      // Translate the applicable parameters according to their rewrite\n      // functions (if provided)\n      const rewriteFunction = isItinerary\n        ? qp.itineraryRewrite\n        : qp.profileRewrite;\n      params = Object.assign(\n        params,\n        rewriteFunction\n          ? rewriteFunction(currentQuery[qp.name])\n          : { [qp.name]: currentQuery[qp.name] }\n      );\n    });\n\n  // Additional processing specific to ITINERARY mode\n  if (isItinerary) {\n    // override ignoreRealtimeUpdates if provided\n    if (typeof ignoreRealtimeUpdates === \"boolean\") {\n      params.ignoreRealtimeUpdates = ignoreRealtimeUpdates;\n    }\n\n    // check date/time validity; ignore both if either is invalid\n    const dateValid = moment(params.date, OTP_API_DATE_FORMAT).isValid();\n    const timeValid = moment(params.time, OTP_API_TIME_FORMAT).isValid();\n\n    if (!dateValid || !timeValid) {\n      delete params.time;\n      delete params.date;\n    }\n\n    // temp: set additional parameters for CAR_HAIL or CAR_RENT trips\n    if (\n      params.mode &&\n      (params.mode.includes(\"CAR_HAIL\") || params.mode.includes(\"CAR_RENT\"))\n    ) {\n      params.minTransitDistance = \"50%\";\n      // increase search timeout because these queries can take a while\n      params.searchTimeout = 10000;\n    }\n\n    // set onlyTransitTrips for car rental searches\n    if (params.mode && params.mode.includes(\"CAR_RENT\")) {\n      params.onlyTransitTrips = true;\n    }\n\n    // Additional processing specific to PROFILE mode\n  } else {\n    // check start and end time validity; ignore both if either is invalid\n    const startTimeValid = moment(\n      params.startTime,\n      OTP_API_TIME_FORMAT\n    ).isValid();\n    const endTimeValid = moment(params.endTime, OTP_API_TIME_FORMAT).isValid();\n\n    if (!startTimeValid || !endTimeValid) {\n      delete params.startTimeValid;\n      delete params.endTimeValid;\n    }\n  }\n\n  // TODO: check that valid from/to locations are provided\n\n  // hack to add walking to driving/TNC trips\n  if (hasCar(params.mode)) {\n    params.mode += \",WALK\";\n  }\n\n  // Replace FLEX placeholder with OTP flex modes\n  if (params.mode) {\n    // Ensure query is in reduced format to avoid replacing twice\n    const reducedMode = reduceOtpFlexModes(params.mode.split(\",\")).join(\",\");\n    params.mode = expandOtpFlexMode(reducedMode);\n  }\n\n  return params;\n}\n"],"file":"query.js"}