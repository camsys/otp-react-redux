{"version":3,"sources":["../src/query.js"],"names":["defaultParams","TIME_FORMATS","OTP_API_TIME_FORMAT","getQueryParamProperty","paramInfo","property","query","ensureSingleAccessMode","queryModes","accessCount","filter","m","length","firstAccess","find","push","getUrlParams","qs","parse","window","location","href","split","getOtpUrlParams","Object","keys","key","startsWith","findLocationType","locations","types","match","l","indexOf","type","summarizeQuery","from","name","to","mode","getTripOptionsFromQuery","keepPlace","options","time","departArrive","date","getDefaultQueryParamValue","param","default","getDefaultQuery","config","defaultQuery","routingType","queryParams","qp","forEach","routingTypes","defaultQueryParams","isParamApplicable","applicable","includes","reduceOtpFlexModes","modes","reduce","prev","cur","newModes","expandOtpFlexMode","map","join","isNotDefaultQuery","activeModes","sort","defaultModes","concat","modesEqual","every","value","index","i","getFirstGeocodeResult","text","geocoderConfig","geocoder","search","then","result","firstResult","features","getLocationFromGeocodedFeature","parseLocationString","parts","coordinates","lat","lon","queryParamToLocation","planParamsToQuery","params","fromPlace","toPlace","arriveBy","parsedTime","isValid","format","intermediatePlaces","maybeNumber","Number","isNaN","planParamsToQueryAsync","getRoutingParams","currentQuery","ignoreRealtimeUpdates","isItinerary","rewriteFunction","itineraryRewrite","profileRewrite","assign","dateValid","OTP_API_DATE_FORMAT","timeValid","minTransitDistance","searchTimeout","onlyTransitTrips","startTimeValid","startTime","endTimeValid","endTime","reducedMode"],"mappings":"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","sourcesContent":["import moment from \"moment\";\nimport getGeocoder from \"@opentripplanner/geocoder/lib\";\nimport qs from \"qs\";\n\nimport {\n  getTransitModes,\n  hasCar,\n  hasTransit,\n  isAccessMode,\n  toSentenceCase\n} from \"./itinerary\";\nimport { coordsToString, matchLatLon, stringToCoords } from \"./map\";\nimport queryParams from \"./query-params\";\nimport {\n  getCurrentTime,\n  getCurrentDate,\n  OTP_API_DATE_FORMAT,\n  OTP_API_TIME_FORMAT\n} from \"./time\";\n\n/* The list of default parameters considered in the settings panel */\n\nexport const defaultParams = [\n  \"wheelchair\",\n  \"maxWalkDistance\",\n  \"maxWalkTime\",\n  \"walkSpeed\",\n  \"maxBikeDistance\",\n  \"maxBikeTime\",\n  \"bikeSpeed\",\n  \"optimize\",\n  \"optimizeBike\",\n  \"maxEScooterDistance\",\n  \"watts\"\n];\n\n/**\n * List of time formats to parse when reading query params.\n */\nconst TIME_FORMATS = [\n  \"HH:mm:ss\",\n  \"h:mm:ss a\",\n  \"h:mm:ssa\",\n  \"h:mm a\",\n  \"h:mma\",\n  \"h:mm\",\n  \"HHmm\",\n  \"hmm\",\n  \"ha\",\n  OTP_API_TIME_FORMAT // 'HH:mm'\n];\n\n/* A function to retrieve a property value from an entry in the query-params\n * table, checking for either a static value or a function */\n\nexport function getQueryParamProperty(paramInfo, property, query) {\n  return typeof paramInfo[property] === \"function\"\n    ? paramInfo[property](query)\n    : paramInfo[property];\n}\n\nexport function ensureSingleAccessMode(queryModes) {\n  // Count the number of access modes\n  const accessCount = queryModes.filter(m => isAccessMode(m)).length;\n\n  // If multiple access modes are specified, keep only the first one\n  if (accessCount > 1) {\n    const firstAccess = queryModes.find(m => isAccessMode(m));\n    queryModes = queryModes.filter(m => !isAccessMode(m) || m === firstAccess);\n\n    // If no access modes are specified, add 'WALK' as the default\n  } else if (accessCount === 0) {\n    queryModes.push(\"WALK\");\n  }\n\n  return queryModes;\n}\n\nexport function getUrlParams() {\n  return qs.parse(window.location.href.split(\"?\")[1]);\n}\n\nexport function getOtpUrlParams() {\n  return Object.keys(getUrlParams()).filter(key => !key.startsWith(\"ui_\"));\n}\n\nfunction findLocationType(\n  location,\n  locations = [],\n  types = [\"home\", \"work\", \"suggested\"]\n) {\n  const match = locations.find(l => matchLatLon(l, location));\n  return match && types.indexOf(match.type) !== -1 ? match.type : null;\n}\n\nexport function summarizeQuery(query, locations = []) {\n  const from =\n    findLocationType(query.from, locations) || query.from.name.split(\",\")[0];\n  const to =\n    findLocationType(query.to, locations) || query.to.name.split(\",\")[0];\n  const mode = hasTransit(query.mode) ? \"Transit\" : toSentenceCase(query.mode);\n  return `${mode} from ${from} to ${to}`;\n}\n\nexport function getTripOptionsFromQuery(query, keepPlace = false) {\n  const options = { ...query };\n  // Delete time/date options and from/to\n  delete options.time;\n  delete options.departArrive;\n  delete options.date;\n  if (!keepPlace) {\n    delete options.from;\n    delete options.to;\n  }\n  return options;\n}\n\n/**\n * Gets the query param's default value that is either a constant or by\n * executing the default value function.\n */\nfunction getDefaultQueryParamValue(param) {\n  return typeof param.default === \"function\" ? param.default() : param.default;\n}\n\n/**\n * Get the default query to OTP based on the given config.\n */\nexport function getDefaultQuery(config = null) {\n  const defaultQuery = { routingType: \"ITINERARY\" };\n  queryParams\n    .filter(qp => \"default\" in qp)\n    .forEach(qp => {\n      defaultQuery[qp.name] = getDefaultQueryParamValue(qp);\n    });\n  if (config) {\n    if (config.routingTypes && config.routingTypes.length > 0) {\n      defaultQuery.routingType = config.routingTypes[0].key;\n    }\n    if (config.defaultQueryParams) {\n      Object.keys(config.defaultQueryParams).forEach(key => {\n        defaultQuery[key] = config.defaultQueryParams[key];\n      });\n    }\n  }\n  return defaultQuery;\n}\n\n/**\n * Determine if the specified query param applies to the given query (based on\n * routing type and the param's own applicable function).\n * @param  paramInfo an entry from query-params.js\n * @param  query     the query against which to check if the param applies\n * @param  config    OTP config\n * @return {Boolean}\n */\nfunction isParamApplicable(paramInfo, query, config) {\n  const { applicable, routingTypes } = paramInfo;\n  if (!routingTypes.includes(query.routingType)) return false;\n  if (typeof applicable === \"function\" && !applicable(query, config)) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Helper method which replaces OTP flex modes with single FLEX mode that's\n * more useful and easier to work with.\n */\nexport function reduceOtpFlexModes(modes) {\n  return modes.reduce((prev, cur) => {\n    const newModes = prev;\n    // Add the current mode if it is not a flex mode\n    if (!cur.includes(\"FLEX\")) {\n      newModes.push(cur);\n      // If it is a flex mode, do not add it but rather add the custom flex mode\n      // if not already present\n    } else if (!newModes.includes(\"FLEX\")) {\n      newModes.push(\"FLEX\");\n    }\n    return newModes;\n  }, []);\n}\n\n/**\n * Helper method to process a mode string, replacing all instances of FLEX\n * with the full set of FLEX modes used by otp-2\n * @param {*} mode a mode String, not an array\n * @returns a mode String, not an array (with flex modes expanded)\n */\nexport function expandOtpFlexMode(mode) {\n  const modes = reduceOtpFlexModes(mode.split(\",\"));\n  return modes\n    .map(m => {\n      // If both the expanded and shrunk modes are included, remove the exapnded one\n      if (m === \"FLEX_EGRESS\" || m === \"FLEX_ACCESS\" || m === \"FLEX_DIRECT\") {\n        if (mode.includes(\"FLEX\")) return \"\";\n      }\n      if (m === \"FLEX\") {\n        return \"FLEX_EGRESS,FLEX_ACCESS,FLEX_DIRECT\";\n      }\n      return m;\n    })\n    .join(\",\");\n}\n\n/**\n * Determines whether the specified query differs from the default query, i.e.,\n * whether the user has modified any trip options (including mode) from their\n * default values.\n */\nexport function isNotDefaultQuery(query, config) {\n  const activeModes = reduceOtpFlexModes(query.mode.split(\",\").sort());\n  if (\n    activeModes.length !== 2 ||\n    activeModes[0] !== \"TRANSIT\" ||\n    activeModes[1] !== \"WALK\"\n  ) {\n    // Default mode is TRANSIT,WALK. If general TRANSIT is not used, check\n    // against available transit modes in config.\n    const defaultModes = getTransitModes(config)\n      .concat([\"WALK\"])\n      .sort();\n    const modesEqual =\n      activeModes.length === defaultModes.length &&\n      activeModes.every((value, index) => {\n        return value === defaultModes[index];\n      });\n    if (!modesEqual) return true;\n  }\n  // If modes are equal, check the remaining params.\n  const defaultQuery = getDefaultQuery(config);\n  for (let i = 0; i < defaultParams.length; i++) {\n    const param = defaultParams[i];\n    const paramInfo = queryParams.find(qp => qp.name === param);\n    // If the parameter applies to the query and does not match the default\n    // value, the query is not default.\n    if (\n      isParamApplicable(paramInfo, query, config) &&\n      query[param] !== defaultQuery[param]\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Geocode utility for returning the first result for the provided place name text.\n * @param  {string} text - text to search\n * @param  {Object} geocoderConfig\n * @return {Location}\n */\nasync function getFirstGeocodeResult(text, geocoderConfig) {\n  const geocoder = getGeocoder(geocoderConfig);\n  // Attempt to geocode search text and return first result if found.\n  // TODO: Import geocoder from @opentripplanner\n  return geocoder.search({ text }).then(result => {\n    const firstResult = result.features && result.features[0];\n    if (firstResult) {\n      return geocoder.getLocationFromGeocodedFeature(firstResult);\n    }\n    return null;\n  });\n}\n\n/**\n * OTP allows passing a location in the form '123 Main St::lat,lon', so we check\n * for the double colon and parse the coordinates accordingly.\n * @param  {string} value - query param for place described above\n * @return {Location} - location or null if the value is falsey or the parsed\n *                      coordinates do not result in both a lat and lon\n */\nexport function parseLocationString(value) {\n  if (!value) return null;\n  const parts = value.split(\"::\");\n  const coordinates = parts[1]\n    ? stringToCoords(parts[1])\n    : stringToCoords(parts[0]);\n  const name = parts[1] ? parts[0] : coordsToString(coordinates);\n  return coordinates.length === 2\n    ? {\n        name: name || null,\n        lat: coordinates[0] || null,\n        lon: coordinates[1] || null\n      }\n    : null;\n}\n\n/**\n * Convert a string query param for a from or to place into a location. If\n * coordinates not provided and geocoder config is present, use the first\n * geocoded result.\n * @param  {string} value\n * @param  {Object} [geocoderConfig=null]\n * @return {Location}\n */\nasync function queryParamToLocation(value, geocoderConfig) {\n  let location = parseLocationString(value);\n  if (!location && value && geocoderConfig) {\n    // If a valid location was not found, but the place name text exists,\n    // attempt to geocode the name.\n    location = await getFirstGeocodeResult(value, geocoderConfig);\n  }\n  return location;\n}\n\n/**\n * Create a otp query based on a the url params.\n *\n * @param  {Object} params An object representing the parsed querystring of url\n *    params.\n */\nexport function planParamsToQuery(params) {\n  const query = {};\n  Object.keys(params).forEach(key => {\n    switch (key) {\n      case \"fromPlace\":\n        query.from = parseLocationString(params.fromPlace);\n        break;\n      case \"toPlace\":\n        query.to = parseLocationString(params.toPlace);\n        break;\n      case \"arriveBy\":\n        query.departArrive =\n          params.arriveBy === \"true\"\n            ? \"ARRIVE\"\n            : params.arriveBy === \"false\"\n            ? \"DEPART\"\n            : \"NOW\";\n        break;\n      case \"date\":\n        query.date = params.date || getCurrentDate();\n        break;\n      case \"time\":\n        {\n          const parsedTime = moment(params.time, TIME_FORMATS);\n          query.time = parsedTime.isValid()\n            ? parsedTime.format(OTP_API_TIME_FORMAT)\n            : getCurrentTime();\n        }\n        break;\n      case \"intermediatePlaces\":\n        // If query has intermediate places, ensure that they are parsed\n        // as locations.\n        query.intermediatePlaces = params.intermediatePlaces\n          ? params.intermediatePlaces.map(parseLocationString)\n          : [];\n        break;\n      default: {\n        const maybeNumber = Number(params[key]);\n        // If the param value is an empty string literal and is not a number,\n        // use string value. Else, use parsed number value.\n        // See https://github.com/opentripplanner/otp-ui/issues/50\n        query[key] =\n          params[key] === \"\" || Number.isNaN(maybeNumber)\n            ? params[key]\n            : maybeNumber;\n        break;\n      }\n    }\n  });\n  return query;\n}\n\n/**\n * Async method to create a otp query based on a the url params. This provides\n * the same functionality as planParamsToQuery, except that it will also attempt\n * to geocode the input from and to strings if no lat/lng values were provided.\n *\n * @param  {Object} params An object representing the parsed querystring of url\n *    params.\n * @param config the config in the otp-rr store.\n */\nexport async function planParamsToQueryAsync(params, config = {}) {\n  // Construct query from plan params.\n  const query = planParamsToQuery(params);\n  // Attempt to geocode from and to params if the string parsing does not return\n  // valid locations.\n  if (!query.from) {\n    query.from = await queryParamToLocation(params.fromPlace, config.geocoder);\n  }\n  if (!query.to) {\n    query.to = await queryParamToLocation(params.toPlace, config.geocoder);\n  }\n  return query;\n}\n\n/**\n * Create an object that can be used as a querystring in making an OTP\n * PlannerResource request.\n *\n * See http://otp-docs.ibi-transit.com/api/resource_PlannerResource.html\n *\n * @param  {Object} config  The OTP application config. See types#configType\n * @param  {Object} currentQuery  The current query parameters as saved in the\n *   application state. This method does some extra logic on top of this data\n *   in order to create a request suitable for OTP. See __tests__/query.js#L14 for more.\n * @param  {boolean} ignoreRealtimeUpdates  If true, will create a request that\n *   does not use realtime data.\n */\nexport function getRoutingParams(config, currentQuery, ignoreRealtimeUpdates) {\n  const routingType = currentQuery.routingType;\n  const isItinerary = routingType === \"ITINERARY\";\n  let params = {};\n\n  // Start with the universe of OTP parameters defined in query-params.js:\n  queryParams\n    .filter(qp => {\n      // A given parameter is included in the request if all of the following:\n      // 1. Must apply to the active routing type (ITINERARY or PROFILE)\n      // 2. Must be included in the current user-defined query\n      // 3. Must pass the parameter's applicability test, if one is specified\n      return (\n        qp.routingTypes.indexOf(routingType) !== -1 &&\n        qp.name in currentQuery &&\n        (typeof qp.applicable !== \"function\" ||\n          qp.applicable(currentQuery, config))\n      );\n    })\n    .forEach(qp => {\n      // Translate the applicable parameters according to their rewrite\n      // functions (if provided)\n      const rewriteFunction = isItinerary\n        ? qp.itineraryRewrite\n        : qp.profileRewrite;\n      params = Object.assign(\n        params,\n        rewriteFunction\n          ? rewriteFunction(currentQuery[qp.name])\n          : { [qp.name]: currentQuery[qp.name] }\n      );\n    });\n\n  // Additional processing specific to ITINERARY mode\n  if (isItinerary) {\n    // override ignoreRealtimeUpdates if provided\n    if (typeof ignoreRealtimeUpdates === \"boolean\") {\n      params.ignoreRealtimeUpdates = ignoreRealtimeUpdates;\n    }\n\n    // check date/time validity; ignore both if either is invalid\n    const dateValid = moment(params.date, OTP_API_DATE_FORMAT).isValid();\n    const timeValid = moment(params.time, OTP_API_TIME_FORMAT).isValid();\n\n    if (!dateValid || !timeValid) {\n      delete params.time;\n      delete params.date;\n    }\n\n    // temp: set additional parameters for CAR_HAIL or CAR_RENT trips\n    if (\n      params.mode &&\n      (params.mode.includes(\"CAR_HAIL\") || params.mode.includes(\"CAR_RENT\"))\n    ) {\n      params.minTransitDistance = \"50%\";\n      // increase search timeout because these queries can take a while\n      params.searchTimeout = 10000;\n    }\n\n    // set onlyTransitTrips for car rental searches\n    if (params.mode && params.mode.includes(\"CAR_RENT\")) {\n      params.onlyTransitTrips = true;\n    }\n\n    // Additional processing specific to PROFILE mode\n  } else {\n    // check start and end time validity; ignore both if either is invalid\n    const startTimeValid = moment(\n      params.startTime,\n      OTP_API_TIME_FORMAT\n    ).isValid();\n    const endTimeValid = moment(params.endTime, OTP_API_TIME_FORMAT).isValid();\n\n    if (!startTimeValid || !endTimeValid) {\n      delete params.startTimeValid;\n      delete params.endTimeValid;\n    }\n  }\n\n  // TODO: check that valid from/to locations are provided\n\n  // hack to add walking to driving/TNC trips\n  if (hasCar(params.mode)) {\n    params.mode += \",WALK\";\n  }\n\n  // Replace FLEX placeholder with OTP flex modes\n  if (params.mode) {\n    // Ensure query is in reduced format to avoid replacing twice\n    const reducedMode = reduceOtpFlexModes(params.mode.split(\",\")).join(\",\");\n    params.mode = expandOtpFlexMode(reducedMode);\n  }\n\n  return params;\n}\n"],"file":"query.js"}